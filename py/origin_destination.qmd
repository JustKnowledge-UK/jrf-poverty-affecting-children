---
title: "Origin destination analysis"
author: Jolyon Miles-Wilson
date: 2025-07-01
format:    
    html:  
        embed-resources: true
        code-fold: true
execute:
    message: false
    warning: false

---

This script uses Census 2021 origin-destination data from https://www.nomisweb.co.uk/sources/census_2021_od to explore where Northubmerland Park residetns work, where workers in the area of Tottenham Hotspur Stadium live, and the residential distribution of workers in other stadium areas in London.

```{python}
# Packages and config
import pandas as pd
import requests
from bs4 import BeautifulSoup
import re
import geopandas as gpd
from shapely.geometry import Point
import matplotlib.pyplot as plt
import contextily as cx
from adjustText import adjust_text
import configparser
import psycopg2
import os
import pickle
import numpy as np
from sklearn.neighbors import BallTree, radius_neighbors_graph
from scipy.spatial import cKDTree
import janitor
import zipfile
import glob
from sqlalchemy import create_engine

config = configparser.ConfigParser()
config.read(os.path.join('..', 'db_config.ini'))

db_params = dict(config['postgresql'])

# Load config
config = configparser.ConfigParser()
config.read(os.path.join('..', 'db_config.ini'))
db_params = dict(config['postgresql'])

# Build SQLAlchemy connection string
conn_str = (
    f"postgresql+psycopg2://{db_params['user']}:{db_params['password']}"
    f"@{db_params['host']}:{db_params['port']}/{db_params['database']}"
)

# Create engine
engine = create_engine(conn_str)
```

```{python}
# Get Haringey MSOAs for subsetting later
with engine.connect() as con:
    query = '''
        SELECT DISTINCT msoa21cd
        FROM pcode_census21_lookup 
        WHERE ladnm = 'Haringey'
    '''
    lookup = pd.read_sql(sql=query, con=con)

# For safe SQL query
formatted_list = ', '.join([f"'{district}'" for district in lookup['msoa21cd'].tolist()])

# query2 = f'''
#     SELECT * 
#     FROM census21_od_workplace_msoa
#     WHERE msoa21cd_residence IN ({formatted_list})
#     OR msoa21cd_workplace IN ({formatted_list})
#     '''

# Union approach much more efficient. Union removes duplicates. Note if I wanted to keep duplicates I could use UNION ALL
with engine.connect() as con:
    query3 = f'''SELECT * FROM census21_od_workplace_msoa
                WHERE msoa21cd_residence IN ({formatted_list})

                UNION

                SELECT * FROM census21_od_workplace_msoa
                WHERE msoa21cd_workplace IN ({formatted_list});
                '''
    od_data = pd.read_sql(con=con, sql=query3)


od_data.to_pickle(os.path.join('..','data','od_data.pkl'))

od_data2 = od_data.copy()

# Sum across type of workplace as we're not interseted in differentiating these
# od_data2['count'] = od_data2.groupby(['msoa21cd_residence','msoa21cd_workplace'])['count'].transform('sum')
# # This is where the duplicates come from
# od_data2 = od_data2.drop_duplicates(subset=['msoa21cd_residence','msoa21cd_workplace','place_of_work_indicator_code'])

cols_to_keep = [
    'msoa21cd_residence',
    'msoa21cd_workplace',
    'count'
]
od_data2 = od_data2[cols_to_keep]

np_code = 'E02000398'
ths_code = 'E02006794'
```

# Where do NP residents work

First take a look at where Northumberland Park residents work using an interactive map.

```{python}
#| include: false
np_residents = od_data2[od_data2['msoa21cd_residence'] == np_code]
#  Maybe chuck a bar plot for context here too
ax = np_residents.groupby('msoa21cd_workplace')['count'].sum()\
    .div(np_residents['count'].sum())\
    .mul(100)\
    .sort_values(ascending=False)\
    .head(20)\
    .plot(kind='barh')

ax.set_xlabel('Percentage of Total Residence Population (%)')
ax.set_ylabel('MSOA Workplace Code')
ax.set_title(f'Top 20 place where residents in {np_code} work')

```

```{python}
#| include: false
# Example: Where do people who live in NP work?
# np_residents = od_data2[od_data2['location']=='np_residence']

# Just get the workplace
workplace_counts = np_residents.groupby('msoa21cd_workplace')['count'].sum().reset_index()
workplace_counts['percentage'] = workplace_counts['count'].div(workplace_counts['count'].sum()) * 100

# Get the MSOA boundaries of the workplaces
areas_of_interest = workplace_counts['msoa21cd_workplace'].tolist() + ['E02000398','E02006794']
formatted_list = ', '.join([f"'{district}'" for district in areas_of_interest])
with engine.connect() as con:
    query = f'''
            SELECT * 
            FROM msoa21_boundaries
            WHERE msoa21cd IN ({formatted_list})
            '''
    msoa_gdf = gpd.read_postgis(con=con, sql=query, geom_col='geometry')

msoa_gdf.to_pickle(os.path.join('..','data','msoa_gdf1.pkl'))

geo_df = msoa_gdf.merge(workplace_counts, left_on='msoa21cd', right_on='msoa21cd_workplace', how='left')
# geo_df['count'] = geo_df['count'].fillna(0)

import plotly.express as px

# Make sure geometry is in WGS84 (EPSG:4326) for Plotly
geo_df = geo_df.to_crs(epsg=4326)

# Create the Plotly choropleth
fig = px.choropleth_mapbox(
    geo_df,
    geojson=geo_df.geometry,
    locations=geo_df.index,  # any unique identifier
    color='percentage',
    hover_name='msoa21cd',  # Optional: show code or name
    color_continuous_scale="Viridis",
    mapbox_style="carto-positron",
    center={"lat": geo_df.geometry.centroid.y.mean(), 
            "lon": geo_df.geometry.centroid.x.mean()},
    zoom=9,  # Adjust depending on your area
    opacity=0.6
)

fig.update_layout(
    title="Where NP Residents Work (MSOA level)",
    margin={"r":0,"t":30,"l":0,"b":0}
)
fig.show()


```

# Where do THS workers live

Now look at where people who work in the Tottenham Hotspur Stadium area live using an interactive map

```{python}
# ths_workers = od_data2[od_data2['location']=='ths_workplace']
ths_workers = od_data2[od_data2['msoa21cd_workplace']==ths_code]
#  Maybe chuck a bar plot for context here too
# ths_workers.groupby('msoa21cd_residence')['count'].sum().sort_values(ascending=False).head(20).plot(kind='barh')

ax = ths_workers.groupby('msoa21cd_residence')['count'].sum()\
    .div(ths_workers['count'].sum())\
    .mul(100)\
    .sort_values(ascending=False)\
    .head(20)\
    .plot(kind='barh')

ax.set_xlabel('Percentage of Total Workplace Population (%)')
ax.set_ylabel('MSOA Residence Code')
ax.set_title(f'Top 20 places where workers in {ths_code} live')

```
```{python}
#| include: false

# just look at the residences
residence_counts = ths_workers.groupby('msoa21cd_residence')['count'].sum().reset_index()
residence_counts['percentage'] = residence_counts['count'].div(residence_counts['count'].sum()) * 100

# Get the MSOA boundaries of the residences
areas_of_interest = residence_counts['msoa21cd_residence'].tolist() + ['E02000398','E02006794']
formatted_list = ', '.join([f"'{district}'" for district in areas_of_interest])

with engine.connect() as con:
    query = f'''
            SELECT * 
            FROM msoa21_boundaries
            WHERE msoa21cd IN ({formatted_list})
            '''
msoa_gdf = gpd.read_postgis(con=con, sql=query, geom_col='geometry')
msoa_gdf.to_pickle(os.path.join('..','data','msoa_gdf2.pkl'))
geo_df = msoa_gdf.merge(residence_counts, left_on='msoa21cd', right_on='msoa21cd_residence', how='left')
# geo_df['count'] = geo_df['count'].fillna(0)

import plotly.express as px

# Make sure geometry is in WGS84 (EPSG:4326) for Plotly
geo_df = geo_df.to_crs(epsg=4326)

# Create the Plotly choropleth
fig = px.choropleth_mapbox(
    geo_df,
    geojson=geo_df.geometry,
    locations=geo_df.index,  # any unique identifier
    color='percentage',
    hover_name='msoa21cd',  # Optional: show code or name
    color_continuous_scale="Viridis",
    mapbox_style="carto-positron",
    center={"lat": geo_df.geometry.centroid.y.mean(), 
            "lon": geo_df.geometry.centroid.x.mean()},
    zoom=9,  # Adjust depending on your area
    opacity=0.6
)

fig.update_layout(
    title="Where THS Workers Live (MSOA level)",
    margin={"r":0,"t":30,"l":0,"b":0}
)
fig.show()


```

Plot static maps of London and Haringey for easier presentation

```{python}
# static version

residence_counts = ths_workers.groupby('msoa21cd_residence')['count'].sum().reset_index()
residence_counts['percentage'] = residence_counts['count'].div(residence_counts['count'].sum()) * 100
residence_counts['log_percentage'] = np.log(residence_counts['percentage'])

# Include specific additional areas
areas_of_interest = residence_counts['msoa21cd_residence'].tolist() + ['E02000398', 'E02006794']
formatted_list = ', '.join([f"'{district}'" for district in areas_of_interest])
with engine.connect() as con:
    query = f'''
        SELECT DISTINCT foo.*, loo.ladnm, poo.rgn21nm
        FROM msoa21_boundaries foo
        LEFT JOIN pcode_census21_lookup loo
        ON foo.msoa21cd = loo.msoa21cd
        LEFT JOIN lad21_lookup poo
        ON loo.ladnm = poo.lad21nm
        WHERE foo.msoa21cd IN ({formatted_list})
    '''
    msoa_gdf = gpd.read_postgis(con=con, sql=query, geom_col='geometry')

# Optional: Save for reuse
msoa_gdf.to_pickle(os.path.join('..', 'data', 'msoa_gdf3.pkl'))

# Merge with residence data
geo_df = msoa_gdf.merge(residence_counts, left_on='msoa21cd', right_on='msoa21cd_residence', how='left')

# Ensure CRS is appropriate for plotting
geo_df = geo_df.to_crs(epsg=3857)  # Web Mercator for plotting with Matplotlib

from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib as mpl

geo_df2 = geo_df.loc[geo_df['rgn21nm']=='London']

# Plotting
fig, ax = plt.subplots(figsize=(10, 10))

# Plot geometries colored by log_percentage
geo_df2.plot(
    column='log_percentage',
    cmap='viridis',
    linewidth=0.5,
    edgecolor='white',
    # legend=True,
    # legend_kwds={'label': 'Log percentage of workers'},
    ax=ax,
    missing_kwds={
        "color": "lightgrey",
        "label": "No data",
    },
    alpha=0.8
)
cx.add_basemap(ax, crs=geo_df2.crs, source=cx.providers.OpenStreetMap.Mapnik)
divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.1)

# Create a dummy mappable for the colorbar
norm = mpl.colors.Normalize(vmin=geo_df2['log_percentage'].min(), vmax=geo_df2['log_percentage'].max())
cmap = plt.cm.viridis
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm._A = []

# Draw the colorbar in the new axes (same height)
cbar = fig.colorbar(sm, cax=cax)
cbar.set_label('Log percentage of workers')

# Format plot
ax.set_title("Where Workers in the Tottenham Hostpur area live (Limited to London residences)", fontsize=14)
ax.axis('off')

plt.tight_layout()
plt.show()


fig.savefig(os.path.join('..','outputs','session3','ths_area_worker_residence_london.png'), dpi=600)

areas = ['Haringey','Enfield','Waltham Forest','Islington']
geo_df3 = geo_df.loc[geo_df['ladnm'].isin(areas)]

# Plotting
fig, ax = plt.subplots(figsize=(10, 10))

# Plot geometries colored by log_percentage
geo_df3.plot(
    column='log_percentage',
    cmap='viridis',
    linewidth=0.5,
    edgecolor='white',
    # legend=True,
    # legend_kwds={'label': 'Log percentage of workers'},
    ax=ax,
    missing_kwds={
        "color": "lightgrey",
        "label": "No data",
    },
    alpha=0.8
)
cx.add_basemap(ax, crs=geo_df3.crs, source=cx.providers.OpenStreetMap.Mapnik)
divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.1)

# Create a dummy mappable for the colorbar
norm = mpl.colors.Normalize(vmin=geo_df3['log_percentage'].min(), vmax=geo_df3['log_percentage'].max())
cmap = plt.cm.viridis
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm._A = []

# Draw the colorbar in the new axes (same height)
cbar = fig.colorbar(sm, cax=cax)
cbar.set_label('Log percentage of workers', fontsize=12)

# Format plot
ax.set_title(f"Where Workers in the Tottenham Hostpur area live\n(Limited to {', '.join(areas)})", fontsize=14)
ax.axis('off')

plt.tight_layout()
plt.show()


fig.savefig(os.path.join('..','outputs','session3','ths_area_worker_residence_haringey_and_locality.png'), dpi=600)
```

# Emirates 

```{python}
#| include: false
# Get the records for emirates 
emirates_code = 'E02000564'
formatted_list = ', '.join([f"'{district}'" for district in [emirates_code]])


query3 = f'''SELECT * FROM census21_od_workplace_msoa
            WHERE msoa21cd_workplace IN ({formatted_list})

            UNION

            SELECT * FROM census21_od_workplace_msoa
            WHERE msoa21cd_residence IN ({formatted_list});
            '''
emirates_od_data = pd.read_sql(con=con, sql=query3)
```

# Exploring all stadia workzones

Plan:

1. Use stadia locations as filter for workplace locations in od_data request
2. Use stadium neighbours to flag areas within 1km of the stadium (note exclude the stadium area from this list) and areas beyond 1km of the stadium. This data was produced in py/premier_league_stadiums.qmd

```{python}
# Load the stadium locations. 
with open(os.path.join('..','data','stadium_locations.pkl'), "rb") as input_file:
    stadia = pickle.load(input_file)

with open(os.path.join('..','data','stadium_neighbours.pkl'), "rb") as input_file:
    stadium_neighbours = pickle.load(input_file)

# Work out the percentage for each distance for each stadium and add to list
results = []
for stadium in stadia['Stadium'].unique():
    stadium_msoa = stadia.loc[stadia['Stadium']==stadium,'msoa21cd'].tolist()[0]
    region = stadia.loc[stadia['Stadium']==stadium,'rgn21nm'].tolist()[0]
    formatted_list = ', '.join([f"'{district}'" for district in [stadium_msoa]])

    with engine.connect() as con:
        query = f'''SELECT * FROM census21_od_workplace_msoa
                    WHERE msoa21cd_workplace IN ({formatted_list});
                    '''
        stadium_workers = pd.read_sql(con=con, sql=query)

    # Get msoas within 1km
    msoas_within_1km = stadium_neighbours.loc[stadium_neighbours['stadium']==stadium, 'msoa21cd'].unique().tolist()
    # Drop the msoa the stadium is in (do we definitely want to do this?)
    msoas_within_1km = [msoa for msoa in msoas_within_1km if msoa not in stadium_msoa]

    stadium_workers['within_1km'] = stadium_workers['msoa21cd_residence'].isin(msoas_within_1km)

    conditions = [
        (stadium_workers['msoa21cd_residence']==stadium_msoa),
        (stadium_workers['msoa21cd_residence'].isin(msoas_within_1km))
    ]

    choices = ["Stadium","Within 1km"]
    stadium_workers['location'] = np.select(conditions, choices, default="Beyond 1km")

    stadium_workers['stadium'] = stadium
    residence_counts = stadium_workers.groupby(['stadium','location'])['count'].sum().reset_index()
    residence_counts['percentage'] = residence_counts['count'].div(residence_counts['count'].sum()).mul(100)
    residence_counts['log_percentage'] = np.log(residence_counts['percentage'])
    
    residence_counts['region'] = region
    front_cols = ['stadium','location','region']
    residence_counts = residence_counts[front_cols + [col for col in residence_counts.columns if col not in front_cols]]

    results.append(residence_counts)

# Concatenate the list into a single df
all_results = pd.concat(results).reset_index(drop=True)

# Plot
import seaborn as sns

custom_order = ['Stadium','Within 1km', 'Beyond 1km']

fig, ax = plt.subplots(figsize=(8, 8))

sns.barplot(
    data=all_results, 
    x='percentage', 
    y='stadium', 
    hue='location', 
    hue_order=custom_order,
    ax=ax)

# Optional: rotate x-axis labels if they overlap
ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha='right')

plt.tight_layout()
plt.show()

# Just London

custom_order = ['Stadium','Within 1km', 'Beyond 1km']

fig, ax = plt.subplots(figsize=(8, 8))

london = all_results.loc[all_results['region']=='London']

sns.barplot(
    data=london, 
    x='percentage', 
    y='stadium', 
    hue='location', 
    hue_order=custom_order,
    ax=ax)


ax.set_xlabel('Percentage')
ax.set_ylabel('')
ax.legend().set_title('')

fig.suptitle('Where workers in a stadium MSOA live')

plt.tight_layout()
plt.show()


fig.savefig(os.path.join('..','outputs','session3','stadium_employment.png'), dpi=600)
```